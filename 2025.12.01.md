[HeroCTF](https://ctf.heroctf.fr)

![](img/8/1.png)

---

***Andor***
---

![](img/8/2.png)

Для решения задачи напишем программу, которая по TCP подключается к серверу, многократно получает пары строк `a` и `o` и побитово обрабатывает их: все значения a последовательно объединяются операцией ИЛИ, а все значения `o` — операцией И. После достаточного числа запросов полученные два блока байтов склеиваются, интерпретируются как текст в кодировке ASCII, и так восстанавливается флаг.

```python
import socket

HOST = "crypto.heroctf.fr"
PORT = 9000

def get_ao(f):
    line = f.readline().decode().strip()
    if not line.startswith("a = "):
        raise RuntimeError("unexpected line: " + line)
    a_hex = line[4:]

    line = f.readline().decode().strip()
    if not line.startswith("o = "):
        raise RuntimeError("unexpected line: " + line)
    o_hex = line[4:]

    f.read(2)

    return bytes.fromhex(a_hex), bytes.fromhex(o_hex)

def main():
    s = socket.create_connection((HOST, PORT))
    f = s.makefile("rwb", buffering=0)

    a, o = get_ao(f)
    l = len(a)

    first = bytearray(l)                
    second = bytearray([0xFF] * len(o))

    for i in range(l):
        first[i] |= a[i]
    for i in range(len(o)):
        second[i] &= o[i]

    for _ in range(100):
        f.write(b"0\n")
        a, o = get_ao(f)

        for i in range(l):
            first[i] |= a[i]

        for i in range(len(o)):
            second[i] &= o[i]

    flag = bytes(first + second)

    try:
        print(flag.decode())
    except UnicodeDecodeError:
        print(flag)

    s.close()

if __name__ == "__main__":
    main()
```

Запустим написанную программу и получим флаг.

![](img/8/3.png)

Проверим флаг.

![](img/8/4.png)

---

***Apprentice of the IR Forge***
---

![](img/8/5.png)

Изменим два файла из выданного архива. В `src/valid_pass.c` реализуем функцию `SWORD_OF_THE_HERO`, которая выполняет нужные вычисления и вызывается из `main`.

`src/valid_pass.c`

```c
#include <stdint.h>

static int storage;

int *SWORD_OF_THE_HERO(int a, int b, int c) {
    storage = a + b + c;
    return &storage;
}

int main(void) {
    (void)SWORD_OF_THE_HERO(1, 2, 3);
    return 0;
}
```

В скрипте `solve_template.py` пропишем логику: открыть изменённый `valid_pass.c`, отправить его содержимое на удалённый сервер по TCP и вывести ответ сервера, в котором и содержится флаг.

`solve_template.py`

```python
from pwn import *

HOST = "reverse.heroctf.fr"
PORT = 7002

VALID_PASS_FILE = "src/valid_pass.c"

def main():
    conn = remote(HOST, PORT)

    with open(VALID_PASS_FILE, "rb") as f:
        code = f.read()

    conn.send(code)
    conn.shutdown('send')

    print(conn.recvall().decode("utf-8"))
    conn.close()

if __name__ == "__main__":
    main()
```

Запустим измененный `solve_template.py` и получим флаг.

![](img/8/6.png)

Проверим полученный флаг.

![](img/8/7.png)

---

***Freeda Simple Hook***
---

![](img/8/8.png)

Распаковываем `app-release.apk` с помощью `apktool` в каталог `app` и просматриваем распакованные файлы на наличие строки флага. Находим упоминания утилит и «хранилища» (`Vault`), но самого флага в явном виде ещё нет.

![](img/8/9.png)

Переходим к smali-коду, находим там метод `get_flag`, который отвечает за выдачу флага. Видно, что он что-то вычисляет.

![](img/8/10.png)

Преобразуем байткод приложения в набор Java-файлов: делаем jar и декомпилируем его, получая человекочитаемый исходный код в каталоге `out_src`.

![](img/8/11.png)

Открываем `Vault.java` из `out_src`, видим нормальный Java-код методов `get_flag()` и `seed()` и строку флага формата Hero{…}.

![](img/8/12.png)

Проверяем найденный флаг.

![](img/8/13.png)

---

***Freeda Not Root***
---

![](img/8/14.png)

Распаковываем `app-release.apk` с помощью `apktool` в отдельный каталог, затем преобразуем код приложения в jar-файл и декомпилируем его в исходники Java, чтобы получить доступ к классу `Vault` и его методу `get_flag()`.

![](img/8/15.png)

Создаём небольшой класс `Runner` с функцией `main`, которая вызывает `Vault.get_flag()` и выводит результат. Компилируем его вместе с jar приложения, запускаем и в выводе напрямую получаем флаг формата `HERO{DID_Y0U_US3_0B3C7I0N?}`.

![](img/8/16.png)

Проверяем полученный флаг.

![](img/8/17.png)
