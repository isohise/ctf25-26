***[XSS - Stockée 1](https://www.root-me.org/fr/Challenges/Web-Client/XSS-Stockee-1)***

---

![](img/10/1.png)

Переходим на страницу форума и видим форму добавления сообщения.

![](img/10/2.png)

Проверяем наличие XSS, отправляя тестовый payload `<script>alert("test")</script>` в поле сообщения.

![](img/10/3.png)

Убеждаемся, что XSS срабатывает.

![](img/10/4.png)

Создаём URL на сервисе webhook.site для перехвата HTTP-запросов с `cookie` администратора.

![](img/10/5.png)

Отправляем XSS-payload, который перенаправляет администратора на webhook.site с его `cookie` в параметрах запроса.

![](img/10/6.png)

При переходе по payload выполняется запрос на webhook.site.

![](img/10/7.png)

Просматриваем полученный запрос на webhook.site и извлекаем `cookie` администратора.

![](img/10/8.png)

Подставляем полученное значение в поле проверки, задача засчитывается.

![](img/10/9.png)

***[Javascript - Obfuscation 3](https://www.root-me.org/fr/Challenges/Web-Client/Javascript-Obfuscation-3)***

---

![](img/10/10.png)

Запускаем задание и видим форму ввода пароля.

![](img/10/11.png)

Пробуем ввести произвольное значение и убеждаемся, что при неверном пароле выводится сообщение об ошибке.

![](img/10/12.png)

В исходном JavaScript-коде находим участок, где пароль собирается из числовых значений. Сначала задана закодированная последовательность, далее она переводится в символы. Часть символов получается не напрямую, а через перестановку и выбор элементов массива, чтобы усложнить понимание. Берем из скрипта только данные для пароля и ту часть логики, которая преобразует их в текст, и на выходе получаем строку пароля в открытом виде.

![](img/10/13.png)

Переносим извлеченную закодированную строку в отдельный код и оставляем только декодирование. Преобразуем каждое число в символ и объединяем символы в одну строку. Таким образом убираем обфускацию и получаем готовый пароль для ввода.

![](img/10/14.png)

Вводим полученный пароль в форму проверки на странице задания.

![](img/10/15.png)
